/**
 * Servidor Backend para StartTech
 * Conecta com MySQL local para testes
 */

const express = require('express');
const mysql = require('mysql2/promise');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '.env') });

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '10mb' })); // Aumentar limite para diagramas grandes

// Configura√ß√£o MySQL
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'starttech_db',
  port: process.env.DB_PORT || 3306
};

console.log('üîß Configura√ß√£o do banco:', {
  host: dbConfig.host,
  user: dbConfig.user,
  database: dbConfig.database,
  port: dbConfig.port,
  hasPassword: !!dbConfig.password
});

// Fun√ß√£o para conectar ao banco
async function connectDB() {
  try {
    const connection = await mysql.createConnection(dbConfig);
    console.log('‚úÖ Conectado ao MySQL com sucesso!');
    return connection;
  } catch (error) {
    console.error('‚ùå Erro ao conectar ao MySQL:', error.message);
    throw error;
  }
}

// Middleware de autentica√ß√£o
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token de acesso requerido' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'secret-key', (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token inv√°lido' });
    }
    req.user = user;
    next();
  });
};

// Importar rotas de controle de acesso
require('./access_control_routes')(app);

// üîê Rota de Login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const connection = await connectDB();

    // Buscar usu√°rio
    const [rows] = await connection.execute(
      'SELECT * FROM users WHERE email = ?',
      [email]
    );

    if (rows.length === 0) {
      await connection.end();
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    const user = rows[0];

    // Verificar senha (para desenvolvimento, vamos aceitar qualquer senha)
    const isValidPassword = password === 'admin' || await bcrypt.compare(password, user.password);

    if (!isValidPassword) {
      await connection.end();
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    // Gerar token
    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email, 
        role: user.role 
      },
      process.env.JWT_SECRET || 'secret-key',
      { expiresIn: '24h' }
    );

    await connection.end();

    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

//  Rota para salvar diagrama
app.post('/api/diagrams', authenticateToken, async (req, res) => {
  try {
    const { name, data } = req.body;
    
    // Valida√ß√£o dos dados
    if (!name || !name.trim()) {
      return res.status(400).json({ error: 'Nome do diagrama √© obrigat√≥rio' });
    }

    if (!data || typeof data !== 'object') {
      return res.status(400).json({ error: 'Dados do diagrama s√£o obrigat√≥rios' });
    }

    // Log para debug
    console.log('üìù Salvando diagrama:', name);
    console.log('üìä Dados recebidos:', JSON.stringify(data).substring(0, 100) + '...');
    
    const connection = await connectDB();

    const [result] = await connection.execute(
      'INSERT INTO diagrams (user_id, name, data) VALUES (?, ?, ?)',
      [req.user.userId, name, JSON.stringify(data)]
    );

    await connection.end();

    console.log('‚úÖ Diagrama salvo com ID:', result.insertId);
    
    res.json({
      id: result.insertId,
      message: 'Diagrama salvo com sucesso!'
    });

  } catch (error) {
    console.error('Erro ao salvar diagrama:', error);
    res.status(500).json({ error: 'Erro ao salvar diagrama' });
  }
});

// üîÑ Rota para atualizar diagrama
app.put('/api/diagrams/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, data } = req.body;
    
    // Valida√ß√£o dos dados
    if (!data || typeof data !== 'object') {
      return res.status(400).json({ error: 'Dados do diagrama s√£o obrigat√≥rios' });
    }

    // Log para debug
    console.log('üîÑ Atualizando diagrama ID:', id);
    console.log('üìä Novos dados:', JSON.stringify(data).substring(0, 100) + '...');
    
    const connection = await connectDB();

    const [result] = await connection.execute(
      'UPDATE diagrams SET name = ?, data = ?, updated_at = NOW() WHERE id = ? AND user_id = ?',
      [name, JSON.stringify(data), id, req.user.userId]
    );

    await connection.end();

    if (result.affectedRows === 0) {
      return res.status(404).json({ error: 'Diagrama n√£o encontrado' });
    }

    console.log('‚úÖ Diagrama ID', id, 'atualizado com sucesso');
    res.json({ message: 'Diagrama atualizado com sucesso!' });

  } catch (error) {
    console.error('Erro ao atualizar diagrama:', error);
    res.status(500).json({ error: 'Erro ao atualizar diagrama' });
  }
});

// üóëÔ∏è Rota para deletar diagrama
app.delete('/api/diagrams/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const connection = await connectDB();

    await connection.execute(
      'DELETE FROM diagrams WHERE id = ? AND user_id = ?',
      [id, req.user.userId]
    );

    await connection.end();

    res.json({ message: 'Diagrama deletado com sucesso!' });

  } catch (error) {
    console.error('Erro ao deletar diagrama:', error);
    res.status(500).json({ error: 'Erro ao deletar diagrama' });
  }
});

// ====================================================
// ROTAS PARA DIAGRAMAS
// ====================================================

// üìÑ Listar diagramas do usu√°rio
app.get('/api/diagrams', authenticateToken, async (req, res) => {
  try {
    const connection = await connectDB();
    
    let query, params;
    
    // Admin pode ver todos os diagramas
    if (req.user.role === 'admin') {
      query = `SELECT d.id, d.name, d.created_at, d.updated_at, d.version, d.user_id,
                      u.name as owner_name, u.email as owner_email
               FROM diagrams d
               JOIN users u ON d.user_id = u.id
               WHERE d.is_active = 1 
               ORDER BY d.updated_at DESC`;
      params = [];
    } else {
      // Usu√°rios normais veem apenas seus diagramas + diagramas compartilhados
      query = `SELECT DISTINCT d.id, d.name, d.created_at, d.updated_at, d.version, d.user_id,
                      u.name as owner_name, u.email as owner_email,
                      CASE 
                        WHEN d.user_id = ? THEN 'owner'
                        ELSE COALESCE(da.access_level, 'view')
                      END as access_level
               FROM diagrams d
               JOIN users u ON d.user_id = u.id
               LEFT JOIN diagram_access da ON d.id = da.diagram_id AND da.user_email = ? AND da.is_active = 1
               WHERE d.is_active = 1 
               AND (d.user_id = ? OR da.user_email = ?)
               ORDER BY d.updated_at DESC`;
      params = [req.user.userId, req.user.email, req.user.userId, req.user.email];
    }
    
    const [rows] = await connection.execute(query, params);
    await connection.end();

    res.json({
      success: true,
      diagrams: rows
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar diagramas:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// üìã Buscar diagrama espec√≠fico
app.get('/api/diagrams/:id', authenticateToken, async (req, res) => {
  try {
    const connection = await connectDB();
    
    let query, params;
    
    // Admin pode acessar qualquer diagrama
    if (req.user.role === 'admin') {
      query = `SELECT d.*, u.name as owner_name, u.email as owner_email
               FROM diagrams d
               JOIN users u ON d.user_id = u.id
               WHERE d.id = ? AND d.is_active = 1`;
      params = [req.params.id];
    } else {
      // Usu√°rios normais: pr√≥prios diagramas + diagramas compartilhados
      query = `SELECT d.*, u.name as owner_name, u.email as owner_email,
                      CASE 
                        WHEN d.user_id = ? THEN 'owner'
                        ELSE COALESCE(da.access_level, NULL)
                      END as access_level
               FROM diagrams d
               JOIN users u ON d.user_id = u.id
               LEFT JOIN diagram_access da ON d.id = da.diagram_id AND da.user_email = ? AND da.is_active = 1
               WHERE d.id = ? AND d.is_active = 1
               AND (d.user_id = ? OR da.user_email = ?)`;
      params = [req.user.userId, req.user.email, req.params.id, req.user.userId, req.user.email];
    }
    
    const [rows] = await connection.execute(query, params);
    await connection.end();

    if (rows.length === 0) {
      return res.status(404).json({
        error: 'Diagrama n√£o encontrado ou acesso negado'
      });
    }

    const diagram = rows[0];
    
    // Parse do JSON data com valida√ß√£o melhorada
    try {
      if (typeof diagram.data === 'string') {
        // Se data √© string, fazer parse
        diagram.data = JSON.parse(diagram.data);
      } else if (typeof diagram.data === 'object' && diagram.data !== null) {
        // Se j√° √© objeto, manter
        console.log('üìÑ Data j√° √© objeto para diagrama:', diagram.id);
      } else {
        // Se √© null ou undefined, usar dados vazios
        console.log('‚ö†Ô∏è Data √© null/undefined para diagrama:', diagram.id);
        diagram.data = { nodes: [], edges: [] };
      }
      
      // Validar estrutura dos dados
      if (!diagram.data.nodes) diagram.data.nodes = [];
      if (!diagram.data.edges) diagram.data.edges = [];
      
      console.log('üìä Diagrama carregado:', diagram.name, 'com', diagram.data.nodes.length, 'n√≥s');
      console.log('üë§ Acesso por:', req.user.email, '| Role:', req.user.role);
      
    } catch (e) {
      console.error('‚ùå Erro ao fazer parse do JSON para diagrama', diagram.id, ':', e);
      console.error('üìÑ Dados problem√°ticos:', typeof diagram.data, diagram.data?.substring?.(0, 100));
      diagram.data = { nodes: [], edges: [] };
    }

    res.json({
      success: true,
      diagram
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar diagrama:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// üíæ Salvar novo diagrama
app.post('/api/diagrams', authenticateToken, async (req, res) => {
  try {
    const { name, data } = req.body;

    if (!name || !data) {
      return res.status(400).json({
        error: 'Nome e dados do diagrama s√£o obrigat√≥rios'
      });
    }

    // Validar estrutura dos dados
    if (!data.nodes || !data.edges || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
      return res.status(400).json({
        error: 'Estrutura de dados inv√°lida. Esperado: {nodes: [], edges: []}'
      });
    }

    const connection = await connectDB();
    const [result] = await connection.execute(
      `INSERT INTO diagrams (user_id, name, data, version) 
       VALUES (?, ?, ?, 1)`,
      [req.user.id, name, JSON.stringify(data)]
    );
    await connection.end();

    res.json({
      success: true,
      diagramId: result.insertId,
      message: 'Diagrama salvo com sucesso'
    });
  } catch (error) {
    console.error('‚ùå Erro ao salvar diagrama:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// ‚úèÔ∏è Atualizar diagrama existente
app.put('/api/diagrams/:id', authenticateToken, async (req, res) => {
  try {
    const { name, data } = req.body;
    const diagramId = req.params.id;

    if (!name || !data) {
      return res.status(400).json({
        error: 'Nome e dados do diagrama s√£o obrigat√≥rios'
      });
    }

    // Validar estrutura dos dados
    if (!data.nodes || !data.edges || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
      return res.status(400).json({
        error: 'Estrutura de dados inv√°lida. Esperado: {nodes: [], edges: []}'
      });
    }

    const connection = await connectDB();
    
    // Verificar se o diagrama existe e pertence ao usu√°rio
    const [checkRows] = await connection.execute(
      'SELECT id FROM diagrams WHERE id = ? AND user_id = ? AND is_active = 1',
      [diagramId, req.user.id]
    );

    if (checkRows.length === 0) {
      await connection.end();
      return res.status(404).json({
        error: 'Diagrama n√£o encontrado'
      });
    }

    // Atualizar diagrama
    const [result] = await connection.execute(
      `UPDATE diagrams 
       SET name = ?, data = ?, version = version + 1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = ? AND user_id = ?`,
      [name, JSON.stringify(data), diagramId, req.user.id]
    );
    await connection.end();

    res.json({
      success: true,
      message: 'Diagrama atualizado com sucesso',
      affected: result.affectedRows
    });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar diagrama:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// üóëÔ∏è Excluir diagrama (soft delete)
app.delete('/api/diagrams/:id', authenticateToken, async (req, res) => {
  try {
    const diagramId = req.params.id;
    const connection = await connectDB();
    
    const [result] = await connection.execute(
      `UPDATE diagrams 
       SET is_active = 0, updated_at = CURRENT_TIMESTAMP 
       WHERE id = ? AND user_id = ? AND is_active = 1`,
      [diagramId, req.user.id]
    );
    await connection.end();

    if (result.affectedRows === 0) {
      return res.status(404).json({
        error: 'Diagrama n√£o encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Diagrama exclu√≠do com sucesso'
    });
  } catch (error) {
    console.error('‚ùå Erro ao excluir diagrama:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// üè• Rota de health check
app.get('/api/health', async (req, res) => {
  try {
    const connection = await connectDB();
    await connection.ping();
    await connection.end();
    
    res.json({ 
      status: 'OK', 
      database: 'Connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      database: 'Disconnected',
      error: error.message 
    });
  }
});

// ====================================================
// IMPORTAR E REGISTRAR ROTAS DE CONTROLE DE ACESSO
// ====================================================

// Carregar rotas no contexto atual (mesmo arquivo)
// As rotas usam o 'app' j√° definido, ent√£o inclu√≠mos o c√≥digo diretamente

// üìã Listar classifica√ß√µes de um diagrama
app.get('/api/diagrams/:diagramId/classifications', authenticateToken, async (req, res) => {
  try {
    const { diagramId } = req.params;
    const connection = await connectDB();
    
    // Verificar se o usu√°rio tem acesso ao diagrama
    let query, params;
    
    // Admin pode acessar qualquer diagrama
    if (req.user.role === 'admin') {
      query = `SELECT d.id, d.user_id, 'owner' as access_level
               FROM diagrams d
               WHERE d.id = ? AND d.is_active = 1`;
      params = [diagramId];
    } else {
      query = `SELECT d.id, d.user_id, da.access_level
               FROM diagrams d
               LEFT JOIN diagram_access da ON d.id = da.diagram_id AND da.user_email = ?
               WHERE d.id = ? AND d.is_active = 1
               AND (d.user_id = ? OR da.is_active = 1)`;
      params = [req.user.email, diagramId, req.user.userId];
    }
    
    const [accessCheck] = await connection.execute(query, params);

    if (accessCheck.length === 0) {
      await connection.end();
      return res.status(403).json({ error: 'Acesso negado ao diagrama' });
    }

    // Buscar classifica√ß√µes do diagrama
    const [classifications] = await connection.execute(`
      SELECT 
        dc.*,
        u.name as created_by_name,
        COUNT(cp.id) as users_with_permission,
        COUNT(tc.id) as tables_with_classification
      FROM diagram_classifications dc
      LEFT JOIN users u ON dc.created_by = u.id
      LEFT JOIN classification_permissions cp ON dc.id = cp.classification_id AND cp.is_active = 1
      LEFT JOIN table_classifications tc ON dc.id = tc.classification_id AND tc.is_active = 1
      WHERE dc.diagram_id = ? AND dc.is_active = 1
      GROUP BY dc.id
      ORDER BY dc.display_order, dc.name
    `, [diagramId]);

    await connection.end();

    res.json({
      success: true,
      classifications,
      hasEditAccess: req.user.role === 'admin' || 
                     accessCheck[0].user_id === req.user.userId || 
                     ['edit', 'admin'].includes(accessCheck[0].access_level)
    });

  } catch (error) {
    console.error('‚ùå Erro ao buscar classifica√ß√µes:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// ‚ûï Criar nova classifica√ß√£o
app.post('/api/diagrams/:diagramId/classifications', authenticateToken, async (req, res) => {
  try {
    const { diagramId } = req.params;
    const { name, description, color, isDefault } = req.body;
    
    if (!name || !name.trim()) {
      return res.status(400).json({ error: 'Nome da classifica√ß√£o √© obrigat√≥rio' });
    }

    const connection = await connectDB();
    
    // Verificar permiss√£o de edi√ß√£o
    const [accessCheck] = await connection.execute(`
      SELECT d.user_id, da.access_level
      FROM diagrams d
      LEFT JOIN diagram_access da ON d.id = da.diagram_id AND da.user_email = ?
      WHERE d.id = ? AND d.is_active = 1
    `, [req.user.email, diagramId]);

    if (accessCheck.length === 0 || 
        (accessCheck[0].user_id !== req.user.userId && 
         !['edit', 'admin'].includes(accessCheck[0].access_level))) {
      await connection.end();
      return res.status(403).json({ error: 'Permiss√£o insuficiente para criar classifica√ß√£o' });
    }

    // Se esta ser√° a classifica√ß√£o padr√£o, remover flag das outras
    if (isDefault) {
      await connection.execute(`
        UPDATE diagram_classifications 
        SET is_default = FALSE 
        WHERE diagram_id = ?
      `, [diagramId]);
    }

    // Inserir nova classifica√ß√£o
    const [result] = await connection.execute(`
      INSERT INTO diagram_classifications 
      (diagram_id, name, description, color, is_default, created_by)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [diagramId, name.trim(), description || '', color || '#3B82F6', isDefault || false, req.user.userId]);

    await connection.end();

    res.json({
      success: true,
      classificationId: result.insertId,
      message: 'Classifica√ß√£o criada com sucesso'
    });

  } catch (error) {
    console.error('‚ùå Erro ao criar classifica√ß√£o:', error);
    if (error.code === 'ER_DUP_ENTRY') {
      res.status(400).json({ error: 'J√° existe uma classifica√ß√£o com este nome neste diagrama' });
    } else {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }
});

// üîç Verificar permiss√µes efetivas do usu√°rio  
app.get('/api/diagrams/:diagramId/my-permissions', authenticateToken, async (req, res) => {
  try {
    const { diagramId } = req.params;
    console.log(`üîç Verificando permiss√µes para diagrama ${diagramId}, usu√°rio: ${req.user.email}, role: ${req.user.role}`);
    const connection = await connectDB();
    
    // Admin tem acesso total a tudo
    if (req.user.role === 'admin') {
      console.log('‚úÖ Usu√°rio √© admin - acesso total concedido');
      await connection.end();
      return res.json({
        success: true,
        isOwner: true,
        hasAccess: true,
        permissions: {}, // Admin pode ver tudo
        visibleTables: [], // Lista vazia = pode ver tudo
        userRole: 'admin'
      });
    }
    
    // Verificar se √© dono do diagrama
    console.log(`üîç Verificando se usu√°rio ${req.user.email} √© dono do diagrama ${diagramId}`);
    const [ownerCheck] = await connection.execute(`
      SELECT user_id FROM diagrams 
      WHERE id = ? AND user_id = ? AND is_active = 1
    `, [diagramId, req.user.userId]);

    const isOwner = ownerCheck.length > 0;
    console.log(`üîç √â dono do diagrama? ${isOwner}`);

    // Se √© dono, tem acesso total
    if (isOwner) {
      console.log('‚úÖ Usu√°rio √© dono - acesso total concedido');
      await connection.end();
      return res.json({
        success: true,
        isOwner: true,
        hasAccess: true,
        permissions: {},
        visibleTables: [],
        userRole: req.user.role
      });
    }

    // Verificar acesso ao diagrama
    const [accessCheck] = await connection.execute(`
      SELECT access_level FROM diagram_access
      WHERE diagram_id = ? AND user_email = ? AND is_active = 1
      AND (expires_at IS NULL OR expires_at > NOW())
    `, [diagramId, req.user.email]);

    if (accessCheck.length === 0) {
      await connection.end();
      return res.json({
        success: true,
        isOwner: false,
        hasAccess: false,
        permissions: {},
        visibleTables: [],
        userRole: req.user.role
      });
    }

    // Buscar permiss√µes espec√≠ficas por classifica√ß√£o
    const [permissions] = await connection.execute(`
      SELECT 
        dc.id as classification_id,
        COALESCE(cp.permission_type, 
          CASE 
            WHEN ? = 'admin' THEN 'admin'
            WHEN ? = 'edit' THEN 'edit'
            WHEN dc.is_default = TRUE THEN 'view'
            ELSE NULL
          END
        ) as permission_type
      FROM diagram_classifications dc
      LEFT JOIN classification_permissions cp ON dc.id = cp.classification_id 
        AND cp.user_email = ? AND cp.is_active = 1
        AND (cp.expires_at IS NULL OR cp.expires_at > NOW())
      WHERE dc.diagram_id = ? AND dc.is_active = 1
    `, [accessCheck[0].access_level, accessCheck[0].access_level, req.user.email, diagramId]);

    // Montar objeto de permiss√µes
    const userPermissions = {};
    permissions.forEach(perm => {
      if (perm.permission_type) {
        userPermissions[perm.classification_id] = perm.permission_type;
      }
    });

    await connection.end();

    res.json({
      success: true,
      isOwner: false,
      hasAccess: true,
      permissions: userPermissions,
      visibleTables: [], // TODO: implementar lista espec√≠fica se necess√°rio
      userRole: req.user.role
    });

  } catch (error) {
    console.error('‚ùå Erro ao verificar permiss√µes:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üîó API dispon√≠vel em: http://localhost:${PORT}/api`);
  console.log(`üè• Health check: http://localhost:${PORT}/api/health`);
  console.log(`üîê Sistema de controle de acesso ativo`);
});

module.exports = app;
